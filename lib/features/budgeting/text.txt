import 'package:flutter/material.dart';
import '../theme/app_theme.dart';
// HEADER


/// Reusable header component with logo and subtitle
/// Used across multiple screens for consistent branding
class AppHeader extends StatelessWidget {
  final String? subtitle;
  final double logoHeight;
  final EdgeInsets padding;

  const AppHeader({
    Key? key,
    this.subtitle,
    this.logoHeight = 100,
    this.padding = const EdgeInsets.symmetric(vertical: 24, horizontal: 32),
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: padding,
      child: Column(
        children: [
          // Logo
          Image.asset(
            'assets/images/logo.png',
            height: logoHeight,
            errorBuilder: (context, error, stackTrace) {
              return Container(
                height: logoHeight,
                width: logoHeight,
                decoration: BoxDecoration(
                  color: AppTheme.primaryPink.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(20),
                ),
                child: const Center(
                  child: Text(
                    'BA',
                    style: TextStyle(
                      fontSize: 40,
                      fontWeight: FontWeight.bold,
                      color: AppTheme.primaryPink,
                    ),
                  ),
                ),
              );
            },
          ),
          const SizedBox(height: 16),
          // Title
          Text(
            'Budget Audit',
            style: AppTheme.h1.copyWith(color: AppTheme.primaryPink),
          ),
          if (subtitle != null) ...[
            const SizedBox(height: 8),
            Text(
              subtitle!,
              style: AppTheme.bodyMedium.copyWith(
                color: AppTheme.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}


// DB

// Keep Categories global, add junction table
class AccountCategories extends drift.Table {
  drift.IntColumn get accountId => integer().references(Accounts, #accountId)();
  drift.IntColumn get categoryId => integer().references(Categories, #categoryId)();
  drift.IntColumn get templateId => integer().references(Templates, #templateId)();

  @override
  Set<drift.Column> get primaryKey => {accountId, categoryId, templateId};
}


// VIEWMODEL

import 'package:flutter/material.dart';
import '../../core/models/models.dart' as models;
import '../../core/services/budget_service.dart';
import '../../core/services/participant_service.dart';
import '../../core/services/service_locator.dart';

enum FilterType { name, totalBudget, participant, color }

enum SortOrder { asc, desc }

class CategoryData {
  String id;
  String name;
  Color color;
  List<AccountData> accounts;
  String? validationError;

  CategoryData({
    required this.id,
    required this.name,
    required this.color,
    List<AccountData>? accounts,
    this.validationError,
  }) : accounts = accounts ?? [];

  double get totalBudget =>
      accounts.fold(0.0, (sum, account) => sum + account.budgetAmount);

  Set<models.Participant> get allParticipants =>
      accounts.expand((a) => a.participants).toSet();

  CategoryData copyWith({
    String? id,
    String? name,
    Color? color,
    List<AccountData>? accounts,
    String? validationError,
  }) {
    return CategoryData(
      id: id ?? this.id,
      name: name ?? this.name,
      color: color ?? this.color,
      accounts: accounts ?? this.accounts,
      validationError: validationError,
    );
  }
}

class AccountData {
  String id;
  String name;
  double budgetAmount;
  List<models.Participant> participants;
  Color color;
  String? validationError;

  AccountData({
    required this.id,
    required this.name,
    required this.budgetAmount,
    List<models.Participant>? participants,
    required this.color,
    this.validationError,
  }) : participants = participants ?? [];

  AccountData copyWith({
    String? id,
    String? name,
    double? budgetAmount,
    List<models.Participant>? participants,
    Color? color,
    String? validationError,
  }) {
    return AccountData(
      id: id ?? this.id,
      name: name ?? this.name,
      budgetAmount: budgetAmount ?? this.budgetAmount,
      participants: participants ?? this.participants,
      color: color ?? this.color,
      validationError: validationError,
    );
  }
}

class BudgetingViewModel extends ChangeNotifier {
  final BudgetService _budgetService = sl<BudgetService>();
  final ParticipantService _participantService = sl<ParticipantService>();

  List<CategoryData> _categories = [];
  List<models.Participant> _allParticipants = [];
  List<models.Template> _templates = [];

  String _searchQuery = '';
  FilterType _currentFilter = FilterType.name;
  SortOrder _sortOrder = SortOrder.asc;
  models.Participant? _filterParticipant;
  Color? _filterColor;

  bool _isLoading = false;
  String? _errorMessage;

  List<CategoryData> get categories => _filteredAndSortedCategories();
  List<models.Participant> get allParticipants => _allParticipants;
  List<models.Template> get templates => _templates;
  String get searchQuery => _searchQuery;
  FilterType get currentFilter => _currentFilter;
  SortOrder get sortOrder => _sortOrder;
  models.Participant? get filterParticipant => _filterParticipant;
  Color? get filterColor => _filterColor;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;

  bool get hasUnsavedChanges => _categories.isNotEmpty;

  bool get canSave {
    if (_categories.isEmpty) return false;

    // Check for at least one category with at least one account
    bool hasValidCategory = _categories.any((cat) => cat.accounts.isNotEmpty);
    if (!hasValidCategory) return false;

    // Check all categories have unique, non-empty names
    final names = _categories.map((c) => c.name.trim().toUpperCase()).toList();
    if (names.any((name) => name.isEmpty || name == 'CATEGORY NAME')) {
      return false;
    }
    if (names.length != names.toSet().length) return false;

    // Check all accounts have names and positive budgets
    for (var category in _categories) {
      for (var account in category.accounts) {
        if (account.name.trim().isEmpty) return false;
        if (account.budgetAmount <= 0) return false;
      }
    }

    return true;
  }

  String? get saveValidationMessage {
    if (_categories.isEmpty) {
      return 'Please add at least one category with an account';
    }

    bool hasValidCategory = _categories.any((cat) => cat.accounts.isNotEmpty);
    if (!hasValidCategory) {
      return 'Each category must have at least one account';
    }

    // Check for duplicate or invalid category names
    final names = _categories.map((c) => c.name.trim().toUpperCase()).toList();
    if (names.any((name) => name.isEmpty || name == 'CATEGORY NAME')) {
      return 'All categories must have valid names';
    }
    if (names.length != names.toSet().length) {
      return 'Category names must be unique';
    }

    // Check account validation
    for (var category in _categories) {
      for (var account in category.accounts) {
        if (account.name.trim().isEmpty) {
          return 'All accounts must have names';
        }
        if (account.budgetAmount <= 0) {
          return 'All accounts must have positive budget amounts';
        }
      }
    }

    return null;
  }

  Future<void> initialize() async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      _allParticipants = await _participantService.getAllParticipants();
      _templates = await _budgetService.templateService.getAllTemplates();
    } catch (e) {
      _errorMessage = 'Failed to load data: $e';
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  void addCategory() {
    final newCategory = CategoryData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: 'CATEGORY NAME',
      color: _generateRandomColor(),
    );
    _categories.add(newCategory);
    notifyListeners();
  }

  void updateCategoryName(String categoryId, String newName) {
    final index = _categories.indexWhere((c) => c.id == categoryId);
    if (index != -1) {
      _categories[index] = _categories[index].copyWith(name: newName);
      _validateCategories();
      notifyListeners();
    }
  }

  void updateCategoryColor(String categoryId, Color newColor) {
    final index = _categories.indexWhere((c) => c.id == categoryId);
    if (index != -1) {
      final category = _categories[index];
      _categories[index] = category.copyWith(color: newColor);

      // Update all account colors to lighter variations
      final updatedAccounts = category.accounts.map((account) {
        return account.copyWith(color: _generateLighterShade(newColor));
      }).toList();

      _categories[index] = _categories[index].copyWith(accounts: updatedAccounts);
      notifyListeners();
    }
  }

  void deleteCategory(String categoryId) {
    _categories.removeWhere((c) => c.id == categoryId);
    notifyListeners();
  }

  void addAccount(String categoryId) {
    final index = _categories.indexWhere((c) => c.id == categoryId);
    if (index != -1) {
      final category = _categories[index];
      final newAccount = AccountData(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        name: 'Account name',
        budgetAmount: 0.0,
        color: _generateLighterShade(category.color),
      );

      final updatedAccounts = [...category.accounts, newAccount];
      _categories[index] = category.copyWith(accounts: updatedAccounts);
      notifyListeners();
    }
  }

  void updateAccountName(String categoryId, String accountId, String newName) {
    final catIndex = _categories.indexWhere((c) => c.id == categoryId);
    if (catIndex != -1) {
      final category = _categories[catIndex];
      final accIndex = category.accounts.indexWhere((a) => a.id == accountId);

      if (accIndex != -1) {
        final updatedAccounts = [...category.accounts];
        updatedAccounts[accIndex] = updatedAccounts[accIndex].copyWith(name: newName);
        _categories[catIndex] = category.copyWith(accounts: updatedAccounts);
        notifyListeners();
      }
    }
  }

  void updateAccountBudget(String categoryId, String accountId, double amount) {
    final catIndex = _categories.indexWhere((c) => c.id == categoryId);
    if (catIndex != -1) {
      final category = _categories[catIndex];
      final accIndex = category.accounts.indexWhere((a) => a.id == accountId);

      if (accIndex != -1) {
        final updatedAccounts = [...category.accounts];
        updatedAccounts[accIndex] = updatedAccounts[accIndex].copyWith(budgetAmount: amount);
        _categories[catIndex] = category.copyWith(accounts: updatedAccounts);
        notifyListeners();
      }
    }
  }

  void updateAccountParticipants(
    String categoryId,
    String accountId,
    List<models.Participant> participants,
  ) {
    final catIndex = _categories.indexWhere((c) => c.id == categoryId);
    if (catIndex != -1) {
      final category = _categories[catIndex];
      final accIndex = category.accounts.indexWhere((a) => a.id == accountId);

      if (accIndex != -1) {
        final updatedAccounts = [...category.accounts];
        updatedAccounts[accIndex] = updatedAccounts[accIndex].copyWith(
          participants: participants,
        );
        _categories[catIndex] = category.copyWith(accounts: updatedAccounts);
        notifyListeners();
      }
    }
  }

  void deleteAccount(String categoryId, String accountId) {
    final catIndex = _categories.indexWhere((c) => c.id == categoryId);
    if (catIndex != -1) {
      final category = _categories[catIndex];
      final updatedAccounts = category.accounts.where((a) => a.id != accountId).toList();
      _categories[catIndex] = category.copyWith(accounts: updatedAccounts);
      notifyListeners();
    }
  }

  void setSearchQuery(String query) {
    _searchQuery = query;
    if (query.isNotEmpty) {
      // Reset to name filter when searching
      _currentFilter = FilterType.name;
    }
    notifyListeners();
  }

  void setFilter(FilterType filter, {SortOrder? order}) {
    _currentFilter = filter;
    if (order != null) {
      _sortOrder = order;
    }
    notifyListeners();
  }

  void setFilterParticipant(models.Participant? participant) {
    _filterParticipant = participant;
    notifyListeners();
  }

  void setFilterColor(Color? color) {
    _filterColor = color;
    notifyListeners();
  }

  void toggleSortOrder() {
    _sortOrder = _sortOrder == SortOrder.asc ? SortOrder.desc : SortOrder.asc;
    notifyListeners();
  }

  void clearFilters() {
    _searchQuery = '';
    _currentFilter = FilterType.name;
    _sortOrder = SortOrder.asc;
    _filterParticipant = null;
    _filterColor = null;
    notifyListeners();
  }

  Future<void> adoptTemplate(models.Template template, int participantId) async {
    // This will be implemented when you finalize the save mechanism
    // For now, it's a placeholder
    _errorMessage = 'Template adoption not yet implemented';
    notifyListeners();
  }

  Future<void> deleteTemplate(int templateId) async {
    try {
      final success = await _budgetService.templateService.deleteTemplate(templateId);
      if (success) {
        _templates.removeWhere((t) => t.templateId == templateId);
        notifyListeners();
      }
    } catch (e) {
      _errorMessage = 'Failed to delete template: $e';
      notifyListeners();
    }
  }

  // Private helper methods

  List<CategoryData> _filteredAndSortedCategories() {
    var filtered = _categories.where((category) {
      // Search filter
      if (_searchQuery.isNotEmpty) {
        final query = _searchQuery.toLowerCase();
        final nameMatch = category.name.toLowerCase().contains(query);
        final accountMatch = category.accounts.any(
          (a) => a.name.toLowerCase().contains(query),
        );
        if (!nameMatch && !accountMatch) return false;
      }

      // Participant filter
      if (_filterParticipant != null) {
        final hasParticipant = category.accounts.any(
          (a) => a.participants.any((p) => p.participantId == _filterParticipant!.participantId),
        );
        if (!hasParticipant) return false;
      }

      // Color filter
      if (_filterColor != null) {
        if (category.color.value != _filterColor!.value) return false;
      }

      return true;
    }).toList();

    // Sort
    filtered.sort((a, b) {
      int comparison;
      switch (_currentFilter) {
        case FilterType.name:
          comparison = a.name.compareTo(b.name);
          break;
        case FilterType.totalBudget:
          comparison = a.totalBudget.compareTo(b.totalBudget);
          break;
        case FilterType.participant:
          comparison = a.allParticipants.length.compareTo(b.allParticipants.length);
          break;
        case FilterType.color:
          comparison = a.color.value.compareTo(b.color.value);
          break;
      }

      return _sortOrder == SortOrder.asc ? comparison : -comparison;
    });

    return filtered;
  }

  Color _generateRandomColor() {
    final colors = [
      const Color(0xFFFF6B9D),
      const Color(0xFF7DD3FC),
      const Color(0xFFA78BFA),
      const Color(0xFF5EEAD4),
      const Color(0xFFFBBF24),
      const Color(0xFFF87171),
      const Color(0xFF34D399),
    ];
    return colors[DateTime.now().millisecondsSinceEpoch % colors.length];
  }

  Color _generateLighterShade(Color baseColor) {
    final hslColor = HSLColor.fromColor(baseColor);
    final lighterHsl = hslColor.withLightness(
      (hslColor.lightness + 0.15).clamp(0.0, 1.0),
    );
    return lighterHsl.toColor();
  }

  void _validateCategories() {
    final names = <String, int>{};

    for (var i = 0; i < _categories.length; i++) {
      final category = _categories[i];
      final normalizedName = category.name.trim().toUpperCase();

      String? error;

      if (normalizedName.isEmpty || normalizedName == 'CATEGORY NAME') {
        error = 'Please provide a valid category name';
      } else if (names.containsKey(normalizedName)) {
        error = 'Category name must be unique';
      }

      names[normalizedName] = i;
      _categories[i] = category.copyWith(validationError: error);
    }
  }
}


// VIEW
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:url_launcher/url_launcher.dart';
import '../../core/theme/app_theme.dart';
import '../../core/widgets/app_header.dart';
import '../../core/widgets/modal_box.dart';
import 'budgeting_viewmodel.dart';
import 'widgets/import_option_card.dart';
import 'widgets/search_filter_bar.dart';
import 'widgets/category_widget.dart';
import 'widgets/template_history_item.dart';

class BudgetingView extends StatefulWidget {
  const BudgetingView({Key? key}) : super(key: key);

  @override
  State<BudgetingView> createState() => _BudgetingViewState();
}

class _BudgetingViewState extends State<BudgetingView> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<BudgetingViewModel>().initialize();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppTheme.backgroundColor,
      body: SafeArea(
        child: Consumer<BudgetingViewModel>(
          builder: (context, viewModel, _) {
            if (viewModel.isLoading) {
              return const Center(child: CircularProgressIndicator());
            }

            return Column(
              children: [
                const AppHeader(
                  subtitle: 'Create and manage your budget templates',
                ),
                Expanded(
                  child: SingleChildScrollView(
                    padding: const EdgeInsets.all(AppTheme.spacingLg),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _buildMainContainer(context, viewModel),
                      ],
                    ),
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }

  Widget _buildMainContainer(BuildContext context, BudgetingViewModel viewModel) {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacingXl),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(AppTheme.radiusXl),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 20,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Title with underline
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Create a Budget Template to start',
                style: AppTheme.h2,
              ),
              const SizedBox(height: AppTheme.spacingXs),
              Container(
                height: 3,
                width: 200,
                decoration: BoxDecoration(
                  color: AppTheme.primaryPink,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
            ],
          ),
          const SizedBox(height: AppTheme.spacingXl),

          // Import options
          LayoutBuilder(
            builder: (context, constraints) {
              if (constraints.maxWidth < 800) {
                // Stack vertically on mobile
                return Column(
                  children: [
                    ImportOptionCard(
                      title: 'Import a default budget template',
                      description: 'A template designed for two individuals',
                      isEnabled: false,
                    ),
                    const SizedBox(height: AppTheme.spacingMd),
                    ImportOptionCard(
                      title: 'Import a custom budget template',
                      description: 'Learn about accepted formats here',
                      isEnabled: false,
                    ),
                    const SizedBox(height: AppTheme.spacingMd),
                    ImportOptionCard(
                      title: 'Import a previous template',
                      description: 'This explores your previous templates',
                      onTap: () => _showTemplateHistory(context, viewModel),
                    ),
                  ],
                );
              }

              // Display in row on larger screens
              return Row(
                children: [
                  Expanded(
                    child: ImportOptionCard(
                      title: 'Import a default budget template',
                      description: 'A template designed for two individuals',
                      isEnabled: false,
                    ),
                  ),
                  const SizedBox(width: AppTheme.spacingMd),
                  Expanded(
                    child: ImportOptionCard(
                      title: 'Import a custom budget template',
                      description: 'Learn about accepted formats here',
                      isEnabled: false,
                    ),
                  ),
                  const SizedBox(width: AppTheme.spacingMd),
                  Expanded(
                    child: ImportOptionCard(
                      title: 'Import a previous template',
                      description: 'This explores your previous templates',
                      onTap: () => _showTemplateHistory(context, viewModel),
                    ),
                  ),
                ],
              );
            },
          ),

          const SizedBox(height: AppTheme.spacing2xl),

          // Learn about budgeting link
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              TextButton.icon(
                onPressed: () => _launchBudgetingGuide(),
                icon: const Icon(Icons.help_outline, size: 16),
                label: Text(
                  'Learn how budgeting works in the Budget Audit',
                  style: AppTheme.bodySmall.copyWith(
                    color: AppTheme.primaryPink,
                    decoration: TextDecoration.underline,
                  ),
                ),
              ),
            ],
          ),

          const SizedBox(height: AppTheme.spacingMd),

          // Search and filter
          const SearchFilterBar(),

          const SizedBox(height: AppTheme.spacingXl),

          // Categories
          if (viewModel.categories.isEmpty)
            _buildEmptyState()
          else
            ...viewModel.categories.map((category) {
              return Padding(
                padding: const EdgeInsets.only(bottom: AppTheme.spacingMd),
                child: CategoryWidget(category: category),
              );
            }),

          const SizedBox(height: AppTheme.spacingMd),

          // Add category button
          InkWell(
            onTap: () => viewModel.addCategory(),
            child: Container(
              padding: const EdgeInsets.all(AppTheme.spacingMd),
              decoration: BoxDecoration(
                border: Border.all(
                  color: AppTheme.primaryPink,
                  width: 2,
                  style: BorderStyle.solid,
                ),
                borderRadius: BorderRadius.circular(AppTheme.radiusLg),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.add_circle_outline,
                    color: AppTheme.primaryPink,
                  ),
                  const SizedBox(width: AppTheme.spacingXs),
                  Text(
                    'Add Category',
                    style: AppTheme.bodyMedium.copyWith(
                      color: AppTheme.primaryPink,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ),
          ),

          const SizedBox(height: AppTheme.spacing2xl),

          // Save/Update buttons
          _buildActionButtons(context, viewModel),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return Container(
      padding: const EdgeInsets.all(AppTheme.spacing2xl),
      decoration: BoxDecoration(
        color: AppTheme.surface,
        borderRadius: BorderRadius.circular(AppTheme.radiusLg),
        border: Border.all(color: AppTheme.border),
      ),
      child: Column(
        children: [
          Icon(
            Icons.category_outlined,
            size: 64,
            color: AppTheme.textTertiary,
          ),
          const SizedBox(height: AppTheme.spacingMd),
          Text(
            'No categories yet',
            style: AppTheme.h3.copyWith(color: AppTheme.textSecondary),
          ),
          const SizedBox(height: AppTheme.spacingXs),
          Text(
            'Add your first category to start building your budget',
            style: AppTheme.bodyMedium.copyWith(color: AppTheme.textTertiary),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildActionButtons(BuildContext context, BudgetingViewModel viewModel) {
    final validationMessage = viewModel.saveValidationMessage;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (validationMessage != null)
          Container(
            margin: const EdgeInsets.only(bottom: AppTheme.spacingMd),
            padding: const EdgeInsets.all(AppTheme.spacingMd),
            decoration: BoxDecoration(
              color: AppTheme.warning.withOpacity(0.1),
              borderRadius: BorderRadius.circular(AppTheme.radiusSm),
              border: Border.all(color: AppTheme.warning),
            ),
            child: Row(
              children: [
                const Icon(Icons.warning_amber, color: AppTheme.warning),
                const SizedBox(width: AppTheme.spacingSm),
                Expanded(
                  child: Text(
                    validationMessage,
                    style: AppTheme.bodyMedium.copyWith(
                      color: AppTheme.warning,
                    ),
                  ),
                ),
              ],
            ),
          ),

        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: viewModel.canSave
                    ? () => _handleSave(context, viewModel)
                    : null,
                style: OutlinedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingMd,
                  ),
                  side: BorderSide(
                    color: viewModel.canSave
                        ? AppTheme.primaryPink
                        : AppTheme.border,
                  ),
                ),
                child: Text(
                  'Save Template',
                  style: AppTheme.button.copyWith(
                    color: viewModel.canSave
                        ? AppTheme.primaryPink
                        : AppTheme.textTertiary,
                  ),
                ),
              ),
            ),
            const SizedBox(width: AppTheme.spacingMd),
            Expanded(
              child: ElevatedButton(
                onPressed: viewModel.canSave
                    ? () => _handleUpdate(context, viewModel)
                    : null,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    vertical: AppTheme.spacingMd,
                  ),
                ),
                child: const Text('Update Template'),
              ),
            ),
          ],
        ),
      ],
    );
  }

  void _showTemplateHistory(BuildContext context, BudgetingViewModel viewModel) {
    showModalBox(
      context: context,
      width: 800,
      height: 600,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Template History',
            style: AppTheme.h2,
          ),
          const SizedBox(height: AppTheme.spacingMd),
          Text(
            'Select a template to adopt or manage your previous templates',
            style: AppTheme.bodyMedium.copyWith(color: AppTheme.textSecondary),
          ),
          const SizedBox(height: AppTheme.spacingLg),
          Expanded(
            child: viewModel.templates.isEmpty
                ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.history,
                    size: 64,
                    color: AppTheme.textTertiary,
                  ),
                  const SizedBox(height: AppTheme.spacingMd),
                  Text(
                    'No previous templates',
                    style: AppTheme.h3.copyWith(
                      color: AppTheme.textSecondary,
                    ),
                  ),
                  const SizedBox(height: AppTheme.spacingXs),
                  Text(
                    'Your saved templates will appear here',
                    style: AppTheme.bodyMedium.copyWith(
                      color: AppTheme.textTertiary,
                    ),
                  ),
                ],
              ),
            )
                : ListView.builder(
              itemCount: viewModel.templates.length,
              itemBuilder: (context, index) {
                final template = viewModel.templates[index];
                return Padding(
                  padding: const EdgeInsets.only(
                    bottom: AppTheme.spacingMd,
                  ),
                  child: TemplateHistoryItem(
                    template: template,
                    participants: [], // TODO: Load participants for template
                    isCurrent: false, // TODO: Check if current
                    onAdopt: () => _handleAdoptTemplate(
                      context,
                      viewModel,
                      template,
                    ),
                    onDelete: () => _handleDeleteTemplate(
                      context,
                      viewModel,
                      template,
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  void _handleAdoptTemplate(
    BuildContext context,
    BudgetingViewModel viewModel,
    template,
  ) {
    if (viewModel.hasUnsavedChanges) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Unsaved Changes'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('You are currently working on a template.'),
              const SizedBox(height: AppTheme.spacingSm),
              if (viewModel.saveValidationMessage != null) ...[
                Container(
                  padding: const EdgeInsets.all(AppTheme.spacingXs),
                  decoration: BoxDecoration(
                    color: AppTheme.warning.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(AppTheme.radiusXs),
                    border: Border.all(color: AppTheme.warning),
                  ),
                  child: Row(
                    children: [
                      const Icon(
                        Icons.warning_amber,
                        size: 16,
                        color: AppTheme.warning,
                      ),
                      const SizedBox(width: AppTheme.spacingXs),
                      Expanded(
                        child: Text(
                          'Note: ${viewModel.saveValidationMessage}',
                          style: AppTheme.bodySmall.copyWith(
                            color: AppTheme.warning,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: AppTheme.spacingSm),
              ],
              const Text('What would you like to do?'),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Cancel'),
            ),
            if (viewModel.canSave)
              TextButton(
                onPressed: () {
                  Navigator.of(context).pop();
                  _handleSave(context, viewModel, then: () {
                    // TODO: Adopt template after saving
                  });
                },
                child: const Text('Save & Adopt'),
              ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
                // TODO: Adopt template
              },
              style: TextButton.styleFrom(
                foregroundColor: AppTheme.error,
              ),
              child: const Text('Discard & Adopt'),
            ),
          ],
        ),
      );
    } else {
      // TODO: Adopt template directly
    }
  }

  void _handleDeleteTemplate(
    BuildContext context,
    BudgetingViewModel viewModel,
    template,
  ) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Template'),
        content: Text(
          'Are you sure you want to delete "${template.templateName}"? This action cannot be undone.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              viewModel.deleteTemplate(template.templateId);
              Navigator.of(context).pop();
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Template deleted successfully'),
                ),
              );
            },
            style: TextButton.styleFrom(
              foregroundColor: AppTheme.error,
            ),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _handleSave(
    BuildContext context,
    BudgetingViewModel viewModel, {
    VoidCallback? then,
  }) {
    if (!viewModel.canSave) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(viewModel.saveValidationMessage ?? 'Cannot save template'),
          backgroundColor: AppTheme.error,
        ),
      );
      return;
    }

    // TODO: Implement save logic
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Save functionality not yet implemented'),
        backgroundColor: AppTheme.warning,
      ),
    );
    then?.call();
  }

  void _handleUpdate(BuildContext context, BudgetingViewModel viewModel) {
    if (!viewModel.canSave) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(viewModel.saveValidationMessage ?? 'Cannot update template'),
          backgroundColor: AppTheme.error,
        ),
      );
      return;
    }

    // TODO: Implement update logic
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Update functionality not yet implemented'),
        backgroundColor: AppTheme.warning,
      ),
    );
  }

  void _launchBudgetingGuide() async {
    // TODO: Add actual URL
    final uri = Uri.parse('https://example.com/budgeting-guide');
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri);
    }
  }
}

// CONTEXT
import 'package:flutter/material.dart';
import '../../core/models/models.dart';

class AppContext extends ChangeNotifier {
  Participant? _currentParticipant;
  Template? _currentTemplate;

  Participant? get currentParticipant => _currentParticipant;
  Template? get currentTemplate => _currentTemplate;

  void setParticipant(Participant participant) {
    _currentParticipant = participant;
    notifyListeners();
  }

  void setCurrentTemplate(Template template) {
    _currentTemplate = template;
    notifyListeners();
  }

  void clearCurrentTemplate() {
    _currentTemplate = null;
    notifyListeners();
  }

  void clear() {
    _currentParticipant = null;
    _currentTemplate = null;
    notifyListeners();
  }
}